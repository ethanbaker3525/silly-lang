/*

silly is a staticly implicitly typed language
with redefinable syntax

expr (_) = 
| primitive (prim)
| if_expr (bool, 'a, 'a)
| definition ()

| = ('a, 'a -> bool)

| not (bool -> bool)
| and (bool, bool -> bool)
| or (bool, bool -> bool)
| xor (bool, bool -> bool)

| + (int|float, int|float -> int|float)
| -
| /
| *
| %
| 


prim = num
      | bool
      | str
      | list

num = int | float 

list = linked_list | static_list

str = char | list chars




*/


// this is a comment

x = 1 // this is defining a value in mem
if x = 1 then // this is testing a conditional
    print "hi" // this is printing a string
else if x = 2  then
    print "he"
else
    print "ho"

make_stuff(x, y, z) = // this is defining an expression
    if x = 1
        y
    else z

make_stuff(1, 2, 4)

fib = 
    match x with
    0 -> 1
    1 -> 1
    n -> fib (n - 1) + fib (n - 2)

if bool 

x = 1
y = 2
z = 3

example_lambda_func = x + y + z

# RULE, YOU CANNOT REDEFINE FUNCS OR VALUES, STATIC LANGUAGE, FUNCTIONAL LANGUAGE

rand_thing = 1 # function that returns 1 OR value that is 1 (THEY ARE THE SAME)
rand_thing = 2 # 1 = 2, comparing two prims
rand_thing() = 1

x = 1 -> multiple meanings, redefine x to equal 1 or check if x is = to 1
while x = 1

# = involving prims is equality check
# = involving 





























all you need to do rn is make a notion of expressions

expressions can have multiple types at once 
(

eg. x = 1 
is expression that returns 1, [type: fun -> int]
expression that sets x to 1, [type: null]
and an expression that returns true if x = 1 [type: bool]

eg. x = y
expr that returns y, x(n) = n [type: fun(x) -> x]
setting x to the value of y [type: null]
checking equality of x and y [type: bool]

eg. x = y = 1
 


)
expressions 




